生产环境事务隔离级别：READ-COMMITED
生产环境：一主两从一备。通过MHA高可用（32C、128G）
主从延迟的场景：
读写分离的场景：


Mysql Server层：（存储过程、视图、触发器）binlog
	连接器：管理连接，权限认证
	查询缓存：sql命中则直接返回结果，mysql8.0版本已经去掉此功能
	分析器：分析sql，词法分析，语法分析（做什么）
	优化器：执行计划生成，索引选择（怎么做）
	执行器：操作引擎，执行sql，返回结果（做）

存储引擎层：数据的存储与提取，提供读写接口，支持InnoDB、MyISAM、Memory等多个存储引擎。redolog、undolog

Innodb引擎把数据放在主键索引上，其他索引保存的都是主键ID，这种称为索引组织表（Index Organizied Table）。
Memory引擎采用的是把数据单独存放，索引上保存数据位置的数据组织形式，这种称为堆组织表（Heap Organizied Table）。只支持表锁。



当前读：读取的是记录的最新版本，读取时还要保证其他事务不能修改当前记录，会对读取的记录加锁。（update、insert、delete、select for update、select lock in share mode）
快照读：不加锁的非阻塞读。快照读的前提是事务隔离级别不是串行级别。快照读的实现是基于MVCC。快照读读取的数据不一定是最新的，有可能是历史版本。（select）
事务中快照读的结果是非常依赖该事务首次出现快照读的地方，即某个事务中首次出现快照读的地方非常关键，它有决定该事务后续快照读结果的能力。

MVCC：Multi-Version Concurrency Control，多版本并发控制。行锁的一个变种，它在很多情况下避免了加锁，降低了开销。解决读-写冲突的无锁并发控制。实现原理主要依赖记录中的4个隐式字段、undolog、Read view来实现的。
4个隐式字段：
DB_ROW_ID：6byte，隐含的自增id（隐藏主键），如果表没有主键，INNODB会自动以DB_ROW_ID产生一个聚簇索引。
DB_TRX_ID：6byte，最近修改（修改/插入）事务ID，记录最后一次修改该记录的事务ID。
DB_ROW_PTR：7byte，回滚指针，指向这条记录的上一个版本。（存储于rollback segment里面）用于配合undolog指向上一个旧版本。
DELETE_BIT：1byte，记录被更新或被删除并不代表真的删除，而是删除flag变了。

Read View：事务进行快照读操作的时候生产的读视图。事务执行快照的那一刻，会生成数据库系统的一个快照，记录并维护系统当前活跃的递增的事务ID。主要用来判断当前事务能够读取哪个版本的数据。ReadView包含三个属性：
trx_list 未提交事务ID列表，用来维护Read View生成时刻系统正活跃的事务ID
up_limit_id 记录trx_list列表中事务ID最小的ID
low_limit_id ReadView生成时刻系统尚未分配的下一个事务ID，也就是目前已出现过的事务ID的最大值+1




undolog：分为3种，insert undolog（记录插入主键id）、update undolog（记录修改前数据）、delete undolog（记录删除的所有数据）。


redolog：物理日志，记录的是“在某个数据页上做了什么修改”。循环写，空间固定会用完；
	写入过程：两种方式：
	1. 事务过程中，先把日志写到redolog buffer中，事务提交的时候，再把redolog buffer写入redolog文件磁盘中。
	2. innodb有个后台线程，每隔1秒就会把redolog buffer中的日志写入磁盘。
binlog：逻辑日志，两种类型（statement、row、mixed），记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。binlog 是可以追加写入的。“追加写”是指binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。
	写入过程：事务执行过程中，先把日志写到binlog cache，事务提交的时候，再把binlog cache写到binlog文件中，然后清空binlog cache。


relay log：
write pos：
checkpoint：



mysql在执行过程中临时使用的内存是管理在连接对象里面的，这些资源会在连接断开的时候才释放，这就可能导致长连接累积下来，导致内存占用大造成OOM。解决办法有两种：
1. 定时断开长连接
2. 如果用的5.7以上版本，可以在每次较大查询后执行mysql_reset_connection来重新初始化连接资源。






先写 redo log 后写 binlog。
假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。
但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。
然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。

先写 binlog 后写 redo log。
如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。


正常流程：
执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。
执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。
引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。
执行器生成这个操作的 binlog，并把 binlog 写入磁盘。
执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。

正常恢复阶段：
如果mysql在redolog的prepare成功，binglog写入之前崩溃，此时由于binlog还未写，redolog还未commit，崩溃恢复的时候，这个事务会回滚。
如果mysql在redolog的prepare成功，binglog写入之后，redolog还未commit时崩溃，崩溃恢复是会进行如下判断：
1. 如果redolog里面的事务是完整的，也就是已经有了commit标识，则直接提交。
2. 如果redolog里面只有完整的prepare，则判断对应的事务binlog是否存在并完整，如果是则提交事务，否则回滚。
一个事务的binlog是有完整格式的，statement格式的binlog最后会有commit。row格式的binlog最后会有一个XID event。
redolog和binlong共同拥有一个相同的XID数据字段。














只用binlog，不用redolog？或者只用redolog，不用binlog？
答：binlog是mysql server的不具备崩溃恢复功能，redolog是innodb的主要做崩溃恢复，binlog主要用来归档、主从同步等功能，所以缺一不可。
redo log buffer 是什么？是先修改内存，还是先写 redo log 文件？
答：redo log buffer 就是一块内存，用来先存 redo 日志的。真正把日志写到 redo log 文件，是在执行 commit 语句的时候做的。












事务（ACID）
A 原子性 redolog
C 一致性
I 隔离性 mvcc和lock
D 持久性 binlog


脏读
不可重复读：一个事务里面，多次查询结果不一致。针对update。
幻读：一个事务在前后两次查询同一个范围的时候，后一次查询看到前一次查询没有看到的行。针对insert和delete。

事务隔离级别
读未提交（Read Uncommitted）：一个事务还未提交时，它做的变更能被其他事务看到。
读已提交（Read Committed）：一个事务提交之后，它做的变更才能被其他事务看到。
可重复读（Repeatable Read）：一个事务执行过程中看到的数据，总是根这个事务在启动时看到的数据一致。当然在可重复读的隔离级别下，未提交的变更对其他事务也是不可见的。
串行化（Serializable）：对于同一行记录，写会加“写锁”，读也会加“读锁”。出现读些锁冲突的时候，后面访问的事务必须等前面事务执行完成。


在RR级别下事务中，第一次快照读的时候会创建一个快照和ReadView，后面的所有操作使用的是同一个ReadView，在ReadView之后的操作对当前事务不可见。
在RC级别下事务中，每一次快照读都会生成并获取最新的ReadView，这就是我们在RC下面事务中可以看到其他事务提交更新的原因。


事务隔离级别的实现：

在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。
在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。
在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。
这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；
而“串行化”隔离级别下直接用加锁的方式来避免并行访问。




索引类型
哈希表：只适合等值查询的场景，无法做区间查询。
有序数组：等值查询和范围查询场景都很优秀，但是更新数据成本太高，如果往中间插入一条数据，则需要挪动后面所有数据。所以只适合静态存储引擎。
搜索树：B+树索引。



索引类型分为主键索引和非主键索引。
主键索引的叶子节点存的是整行数据。主键索引也被称为聚簇索引（clustered index）。
非主键索引的叶子节点内容是主键的值。非主键索引也被称为二级索引（secondary index）。

覆盖索引：从非主键索引中就能查到的记录，而不需要查询主键索引中的记录，避免了回表的产生减少了树的搜索次数，显著提升性能。
前缀索引：最左前缀匹配规则。
索引下推：MySQL 5.6引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数，提高查询效率。执行计划显示Use Index Condition就表示使用了索引下推。


InnoDB会把主键字段放到索引定义字段后面。


页分裂：
页合并：
页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约50%。
脏页：内存数据页和磁盘数据页内容不一致。刷脏页的时候，如果这个数据页的旁边的数据页是脏页，也会一起刷掉。
干净页：内存数据写入到磁盘后，内存和磁盘上的数据页就一致了。

InnoDB使用缓冲池（Buffer Pool）管理内存。缓冲池中的内存页包含三种状态：未被使用、干净页、脏页。
当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。

Buffer Pool采用LRU算法（最近最少使用 Least Recently Used）。使用链表来实现。整个链表分为两部分，按照5:3的比例分为young区和old区。
1. 访问数据页时，如果当前数据页在young区，则直接将其移动到young区链表头部。
2. 如果访问数据页不存在链表中，淘汰链表尾部数据页，在old区的头部插入一个数据页。
3. 在old区的数据页每次访问时，如果当前数据页在链表中存活时间超过1秒，则移动到young区的头部。如果短于1秒，则保持不变。
如果多表join查询冷表数据，可能会影响LRU算法。



刷脏页影响性能的情况：
1、一个查询要淘汰的脏页过多，会导致查询的响应时间变长。
2、日志写满，更新全部堵住，写性能跌未0。







读锁之间是不互斥的，读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。

全局锁：是对整个数据库实例加锁。MySQL提供了一个加全局读锁的方法，命令是Flush tables with read lock (FTWRL)。当整个库处于只读状态时，其他非读操作会被阻塞。全局锁的典型使用场景是做全库逻辑备份。
表级锁：表锁和元数据锁（meta data lock，MDL）。表锁的语法是 lock tables … read/write。可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。MDL不需要显示使用，在访问一个表的时候会自动加上。MDL的作用是确保读写的正确性。MDL写锁主要是用于对表结构的变更。
行锁：行锁就是针对数据表中行记录的锁。在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。

间隙锁（Gap Lock）：锁的是两个值之间的空隙。在一行行扫描的过程中，不仅将给行加上了行锁，还给行两边的空隙，也加上了间隙锁。？？？？（21）

间隙锁和行锁合称next key lock。前开后闭区间。

间隙锁规则：
唯一索引等值查询：
1.当查询的记录是存在的，next-key lock 会退化成「行锁」。
2.当查询的记录是不存在的，next-key lock 会退化成「间隙锁」。

非唯一索引等值查询：
1.当查询的记录存在时，除了会加 next-key lock 外，还额外加间隙锁，也就是会加两把锁。
2.当查询的记录不存在时，只会加 next-key lock，然后会退化为间隙锁，也就是只会加一把锁。

非唯一索引和主键索引的范围查询的加锁规则不同之处在于：
唯一索引在满足一些条件的时候，next-key lock 退化为间隙锁和行锁。
非唯一索引范围查询，next-key lock 不会退化为间隙锁和行锁。


原则 1：加锁的基本单位是 next-key lock。next-key lock 是前开后闭区间。
原则 2：查找过程中访问到的对象才会加锁。
优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。
优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。
一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。








change buffer只限于用在普通索引的场景下，而不适用于唯一索引。
当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB会将这些更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。
将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 merge。merge过程：
1、从磁盘读入数据页到内存（老版本的数据页）；
2、从 change buffer 里找出这个数据页的 change buffer 记录 (可能有多个），依次应用，得到新版数据页；
3、写 redo log。这个 redo log 包含了数据的变更和 change buffer 的变更。





全字段排序
1. 初始化 sort_buffer，确定放入两个字段，即 name 和 id；
2. 从索引 city 找到第一个满足 city='杭州’条件的主键 id，也就是图中的 ID_X；
3. 到主键 id 索引取出整行，取 name、id 这两个字段，存入 sort_buffer 中；
4. 从索引 city 取下一个记录的主键 id；
5. 重复步骤 3、4 直到不满足 city='杭州’条件为止，也就是图中的 ID_Y；
6. 对 sort_buffer 中的数据按照字段 name 进行排序；
7. 遍历排序结果，取前 1000 行，并按照 id 的值回到原表中取出 city、name 和 age 三个字段返回给客户端。

rowid 排序
1. 从索引 (city,name) 找到第一个满足 city='杭州’条件的主键 id；
2. 到主键 id 索引取出整行，取 name、city、age 三个字段的值，作为结果集的一部分直接返回；
3. 从索引 (city,name) 取下一个记录主键 id；
4. 重复步骤 2、3，直到查到第 1000 条记录，或者是不满足 city='杭州’条件时循环结束。





归并排序算法
优先队列算法










锁升级
意向锁



主从同步：
1. 在备库 B 上通过 change master 命令，设置主库 A 的 IP、端口、用户名、密码，以及要从哪个位置开始请求 binlog，这个位置包含文件名和日志偏移量。
2. 在备库 B 上执行 start slave 命令，这时候备库会启动两个线程，就是图中的 io_thread 和 sql_thread。其中 io_thread 负责与主库建立连接。
3. 主库 A 校验完用户名、密码后，开始按照备库 B 传过来的位置，从本地读取 binlog，发给 B。
4. 备库 B 拿到 binlog 后，写到本地文件，称为中转日志（relay log）。
5. sql_thread 读取中转日志，解析出日志里的命令，并执行。


并行复制策略（一个sql_thread分发给多个worker线程处理）遵循规则：binlog必须是row格式。
Mysql5.6提供的并行复制策略支持按库分发，Mysql5.7的并行复制策略。binlog里面包含复制策略需要的并行复制的信息。


GTID： Global Transaction Identifier，也就是全局事务ID，事务提交时生成。主要用于主备切换。



总结就是必须按表分发和按行分发。事务分发冲突的情况：
1. 如果跟所有workder都不冲突，sql_thread线程就会把这个事务分配给最空闲的worker。
2. 如果跟大于1个worker冲突，则sql_thread线程进入等待状态，直到和这个事务存在冲突的worker只剩一个。
3. 如果只跟一个worker冲突，sql_thread会把这个事务分配给这个存在冲突的worker。





互为主备同步过程：
1、从节点 A 更新的事务，binlog 里面记的都是 A 的 server id；
2、传到节点 B 执行一次以后，节点 B 生成的 binlog 的 server id 也是 A 的 server id；
3、再传回给节点 A，A 判断到这个 server id 与自己的相同，就不会再处理这个日志。所以，死循环在这里就断掉了



主从恢复策略：
可靠性优先策略
1. 在图 1 的双 M 结构下，从状态 1 到状态 2 切换的详细过程是这样的：
2. 判断备库 B 现在的 seconds_behind_master，如果小于某个值（比如 5 秒）继续下一步，否则持续重试这一步；
3. 把主库 A 改成只读状态，即把 readonly 设置为 true；
4. 判断备库 B 的 seconds_behind_master 的值，直到这个值变成 0 为止；
5. 把备库 B 改成可读写状态，也就是把 readonly 设置为 false；
6. 把业务请求切到备库 B。

可用性优先策略
4. 判断备库 B 的 seconds_behind_master 的值，直到这个值变成 0 为止；
5. 把备库 B 改成可读写状态，也就是把 readonly 设置为 false；
1. 在图 1 的双 M 结构下，从状态 1 到状态 2 切换的详细过程是这样的：
2. 判断备库 B 现在的 seconds_behind_master，如果小于某个值（比如 5 秒）继续下一步，否则持续重试这一步；
3. 把主库 A 改成只读状态，即把 readonly 设置为 true；
6. 把业务请求切到备库 B。




主备延迟，读写分离方案：
1. 强制走主库方案；
2. sleep 方案；
3. 判断主备无延迟方案；
4. 配合 semi-sync 方案；
5. 等主库位点方案；
6. 等 GTID 方案。

判断mysql是否正常
1. select 1，缺点：慢sql占满并发线程时，select 1成功，此时无法查询
2. 查表，缺点：binlog占用磁盘100%时，查表会成功，此时无法写入
3. 更新表，缺点：更新时间耗时长，磁盘io比较频繁
4. mysql内部自己判断



误删数据解决办法
1. 误删行，可以通过binlog恢复
2. 误删库、表，需要使用全量备份日志加增量日志恢复。要求定期全量备份和实时备份binlog。
误删数据预防措施
1. 延迟复制备库，可以考虑搭建延迟复制的备库，设置主从同步的延迟时间。
2. 删除权限隔离。



kill终止失败的情况
1. 超大事务执行期间执行kill。回滚操作需要对事务期间生成所有数据版本做回收操作，耗时较长。
2. 大查询回滚。如果查询过程中生成了比较大的临时文件，加上此时文件系统压力大，删除临时文件需要等待IO资源，导致耗时较长。
3. 大表DDL执行到最后阶段。如果被kill，需要删除中间过程中的临时文件，可能受IO资源影响耗时较长。

这些“kill 不掉”的情况，其实是因为发送kill命令的客户端，并没有强行停止目标线程的执行，而只是设置了个状态，并唤醒对应的线程。而被kill的线程，需要执行到判断状态的“埋点”，才会开始进入终止逻辑阶段。并且，终止逻辑本身也是需要耗费时间的。














定期全量备份的周期有的是一天一备，有的是一周一备。那么在什么场景下，一天一备会比一周一备更有优势呢？它影响了这个数据库系统的哪个指标？
答：影响系统“最长恢复时间”指标。备份周期越短，则恢复时间越短。

如果你是业务开发负责人同时也是数据库负责人，你会有什么方案来避免出现或者处理长事务这种情况呢？
答：1.通过 SET MAX_EXECUTION_TIME 命令，来控制每个语句执行的最长时间。2.监控 information_schema.Innodb_trx 表，设置长事务阈值，超过就报警 / 或者 kill；

基于主键索引和普通索引的查询有什么区别？
答：基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。

mysql索引的B+树的层级可以调整吗？
答：

为什么要重建索引？怎么重建主键索引？
答：索引可能因为删除，或者页分裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据按顺序插入，这样页面的利用率最高，也就是索引更紧凑、更省空间。
使用alter table T engine=InnoDB重建主键索引。

备份需要全库只读，为什么不使用 set global readonly=true 的方式呢？
答：一是，在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。二是，在异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。

innodb行级锁是通过锁索引记录实现的，如果update的列没建索引，即使只update一条记录也会锁定整张表吗？
答：是的。但是你可以再往前考虑一下，如果是 你的update 语句后面加个limit 1, 会怎么锁？


change buffer一开始是写内存的，那么如果这个时候机器掉电重启，会不会导致 change buffer 丢失呢？change buffer 丢失可不是小事儿，再从磁盘读入数据可就没有了 merge 过程，就等于是数据丢失了。会不会出现这种情况呢？
答：不会丢失，虽然是只更新内存，但是在事务提交的时候，我们把 change buffer 的操作也记录到 redo log 里了，所以崩溃恢复的时候，change buffer 也能找回来。

mysql怎么选择索引？
答：索引的区分度，InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。

什么情况会引发数据库的 flush 过程呢？
答：1、当InnoDB的redolog写满时，系统会停止所有更新操作，把checkpoint往前推进，redolog留出空间可以继续写。
2、当需要新的内存页，而内存不够时，就需要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就需要先将脏页写到磁盘。
3、Mysql正常关闭时，会把所有的脏页都刷到磁盘。
4、空闲时

Mysql抖动的原因？
答：数据库在flush

表数据删除了一半，表文件大小不变？
答：delete只是打标记，数据页被标记可复用，磁盘不会变，需要重建表才会。

我的主机内存只有 100G，现在要对一个 200G 的大表做全表扫描，会不会把数据库主机的内存用光了？
答：不会，mysql是边读边发的。一个查询占用mysql的内存最大就是net_buffer_length这么大。两个参数设置mysql处理逻辑：
mysql_store_result：直接把查询结果保存到本地内存。
mysql_use_result：读一行，处理一行。






count(*)、count(主键 id)、count(字段) 和 count(1) 等不同用法的性能，有哪些差别？
答：按照效率排序的话，count(字段)<count(主键 id)<count(1)≈count(*)，所以我建议你，尽量使用 count(*)。
count(*)并不会把全部字段取出来，而是专门做了优化，不取值。count(*) 肯定不是 null，按行累加。
count(主键 id)InnoDB引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。
count(1)InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。




mysql online ddl？
Online DDL的过程是这样的：
1. 拿MDL写锁
2. 降级成MDL读锁
3. 真正做DDL
4. 升级成MDL写锁
5. 释放MDL锁
1、2、4、5如果没有锁冲突，执行时间非常短。第3步占用了DDL绝大部分时间，这期间这个表可以正常读写数据，是因此称为“online ”


重建表的流程：
建立一个临时文件，扫描表 A 主键的所有数据页；
用数据页中表 A 的记录生成 B+ 树，存储到临时文件中；
生成临时文件的过程中，将所有对 A 的操作记录在一个日志文件（row log）中，对应的是图中 state2 的状态；
临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 A 相同的数据文件，对应的就是图中 state3 的状态；
用临时文件替换表 A 的数据文件。






group by优化的方案：
1. 如果group by没有排序要求，要在语句后面追加order by null
2. 尽量让group by用上表的索引
3. 如果group by的数据量不大，尽量使用内存临时表
4. 如果group by的数据量比较大，使用SQL_BIG_RESULT来告诉优化器使用排序算法得到group by结果



varchar字段长度影响








